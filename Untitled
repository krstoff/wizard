(defun fsm-push (fsm chars value)
  (if (null chars)
    (if (assoc :VALUE fsm)
      (progn
        (setf (cdr (assoc :VALUE fsm)) value)
        fsm)
      (acons :value value fsm))
    (if (assoc (car chars) fsm)
      (progn
        (setf (cdr (assoc (car chars) fsm))
          (fsm-push (cdr (assoc (car chars) fsm)) (cdr chars) value))
        fsm)
      (acons (car chars) (fsm-push nil (cdr chars) value) fsm))))

(defun cat (s1 s2)
  (concatenate 'string (string s1) (string s2)))


(defun make-cases (fsm s)
  (iterate
    (for case in fsm)
    (if (eq (car case) :value)
        (next-iteration))
    (collect `(,(car case) ,(make-state-transitions (cdr (assoc (car case) fsm)) (cat s (car case)))))))

(defun make-state-transitions (fsm &optional (s ""))
  (cond
    ;; siblings, but no node
    ((null (assoc :value fsm))
     `(progn
        (advance stream)
        (case (peek stream)
          ,@(make-cases fsm s)
          ((nil) (error "Unknown operator ~a" ,s))
          (t (error "Unknown operator ~a" (cat ,s (peek stream)))))))
    ;; node, but no siblings
    ((null (set-difference fsm '((:value . nil)) :key #'car))
     `(progn
        (advance stream)
        ,(assoc :value fsm)))
    ;; node and siblings
    (t
     `(progn
        (advance stream)
        (case (peek stream)
          ,@(make-cases fsm s)
          (t ,(car (assoc :value fsm))))))))
